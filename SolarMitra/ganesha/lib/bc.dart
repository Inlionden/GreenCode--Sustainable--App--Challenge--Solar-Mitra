import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:uuid/uuid.dart'; // For generating unique IDs
import 'dart:math'; // For min/max functions
import 'package:intl/intl.dart'; // For date formatting

// Import firebase_options.dart (generated by FlutterFire CLI)
import 'firebase_options.dart';

final Uuid uuid = Uuid(); // Instantiate Uuid once
const String currentUserId = "install_01"; // Hardcoded user ID for simulation

// --- Existing Data Models (SolarPanel, RooftopSection) ---
// ... (Your existing SolarPanel and RooftopSection classes remain the same)
class SolarPanel {
  String id;
  String modelName;
  double lengthM;
  double widthM;
  int wattageW;
  bool isFaulty;
  DateTime addedTimestamp;

  SolarPanel({
    required this.id,
    required this.modelName,
    required this.lengthM,
    required this.widthM,
    required this.wattageW,
    this.isFaulty = false,
    required this.addedTimestamp,
  });

  double get areaM2 => lengthM * widthM;

  Map<String, dynamic> toJson() => {
        'id': id,
        'modelName': modelName,
        'lengthM': lengthM,
        'widthM': widthM,
        'wattageW': wattageW,
        'isFaulty': isFaulty,
        'addedTimestamp': addedTimestamp.toIso8601String(),
      };

  factory SolarPanel.fromJson(Map<String, dynamic> json) {
    return SolarPanel(
      id: json['id'] as String,
      modelName: json['modelName'] as String,
      lengthM: (json['lengthM'] as num).toDouble(),
      widthM: (json['widthM'] as num).toDouble(),
      wattageW: (json['wattageW'] as num).toInt(),
      isFaulty: json['isFaulty'] as bool? ?? false,
      addedTimestamp: DateTime.parse(json['addedTimestamp'] as String),
    );
  }
}

class RooftopSection {
  String id;
  String name;
  double roofLengthM;
  double roofWidthM;
  Map<String, SolarPanel> panels;

  RooftopSection({
    required this.id,
    required this.name,
    required this.roofLengthM,
    required this.roofWidthM,
    Map<String, SolarPanel>? panels,
  }) : this.panels = panels ?? {};

  double get totalAreaM2 => roofLengthM * roofWidthM;

  double get usedAreaM2 {
    return panels.values.fold(0.0, (sum, panel) => sum + panel.areaM2);
  }

  double get remainingAreaM2 => max(0, totalAreaM2 - usedAreaM2);

  int get totalWattageW {
    return panels.values.fold(0, (sum, panel) => sum + panel.wattageW);
  }

  int get activeWattageW {
    return panels.values
        .where((p) => !p.isFaulty)
        .fold(0, (sum, panel) => sum + panel.wattageW);
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'roofLengthM': roofLengthM,
        'roofWidthM': roofWidthM,
        'panels': panels.map((key, value) => MapEntry(key, value.toJson())),
      };

  factory RooftopSection.fromJson(Map<String, dynamic> json) {
    final panelData = json['panels'] as Map<dynamic, dynamic>?;
    final Map<String, SolarPanel> parsedPanels = {};
    if (panelData != null) {
      panelData.forEach((key, value) {
        if (key is String && value is Map) {
          parsedPanels[key] =
              SolarPanel.fromJson(value.cast<String, dynamic>());
        }
      });
    }
    return RooftopSection(
      id: json['id'] as String,
      name: json['name'] as String,
      roofLengthM: (json['roofLengthM'] as num).toDouble(),
      roofWidthM: (json['roofWidthM'] as num).toDouble(),
      panels: parsedPanels,
    );
  }
}


// --- NEW Blockchain/Trading Data Models ---

class UserWallet {
  String userId;
  double balanceSolarCredits; // The currency of our P2P network
  DateTime? lastPoSWClaimTimestamp;

  UserWallet({
    required this.userId,
    this.balanceSolarCredits = 100.0, // Initial balance for new users
    this.lastPoSWClaimTimestamp,
  });

  Map<String, dynamic> toJson() => {
        'userId': userId,
        'balanceSolarCredits': balanceSolarCredits,
        'lastPoSWClaimTimestamp': lastPoSWClaimTimestamp?.toIso8601String(),
      };

  factory UserWallet.fromJson(Map<String, dynamic> json) {
    return UserWallet(
      userId: json['userId'] as String,
      balanceSolarCredits: (json['balanceSolarCredits'] as num? ?? 0.0).toDouble(),
      lastPoSWClaimTimestamp: json['lastPoSWClaimTimestamp'] != null
          ? DateTime.parse(json['lastPoSWClaimTimestamp'] as String)
          : null,
    );
  }
}

class PoSWRecord {
  String id;
  String userId;
  DateTime timestamp;
  int wattageClaimedW; // Total active wattage at the time of claim
  double creditsEarned;

  PoSWRecord({
    required this.id,
    required this.userId,
    required this.timestamp,
    required this.wattageClaimedW,
    required this.creditsEarned,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'userId': userId,
        'timestamp': timestamp.toIso8601String(),
        'wattageClaimedW': wattageClaimedW,
        'creditsEarned': creditsEarned,
      };

  factory PoSWRecord.fromJson(Map<String, dynamic> json) {
    return PoSWRecord(
      id: json['id'] as String,
      userId: json['userId'] as String,
      timestamp: DateTime.parse(json['timestamp'] as String),
      wattageClaimedW: (json['wattageClaimedW'] as num).toInt(),
      creditsEarned: (json['creditsEarned'] as num).toDouble(),
    );
  }
}

enum EnergyOfferStatus { open, filled, cancelled }

class EnergyOffer {
  String id;
  String sellerId;
  double amountWh; // Amount of energy offered in Watt-hours
  double pricePerWh; // Price in SolarCredits per Wh
  DateTime timestamp;
  EnergyOfferStatus status;

  EnergyOffer({
    required this.id,
    required this.sellerId,
    required this.amountWh,
    required this.pricePerWh,
    required this.timestamp,
    this.status = EnergyOfferStatus.open,
  });

  double get totalPrice => amountWh * pricePerWh;

  Map<String, dynamic> toJson() => {
        'id': id,
        'sellerId': sellerId,
        'amountWh': amountWh,
        'pricePerWh': pricePerWh,
        'timestamp': timestamp.toIso8601String(),
        'status': status.toString().split('.').last, // Store enum as string
      };

  factory EnergyOffer.fromJson(Map<String, dynamic> json) {
    return EnergyOffer(
      id: json['id'] as String,
      sellerId: json['sellerId'] as String,
      amountWh: (json['amountWh'] as num).toDouble(),
      pricePerWh: (json['pricePerWh'] as num).toDouble(),
      timestamp: DateTime.parse(json['timestamp'] as String),
      status: EnergyOfferStatus.values.firstWhere(
        (e) => e.toString().split('.').last == (json['status'] as String? ?? 'open'),
        orElse: () => EnergyOfferStatus.open,
      ),
    );
  }
}

class EnergyTransaction {
  String id;
  String sellerId;
  String buyerId;
  String offerId; // The offer this transaction fulfilled
  double amountWh;
  double pricePerWh;
  double totalCostSolarCredits;
  DateTime timestamp;

  EnergyTransaction({
    required this.id,
    required this.sellerId,
    required this.buyerId,
    required this.offerId,
    required this.amountWh,
    required this.pricePerWh,
    required this.totalCostSolarCredits,
    required this.timestamp,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'sellerId': sellerId,
        'buyerId': buyerId,
        'offerId': offerId,
        'amountWh': amountWh,
        'pricePerWh': pricePerWh,
        'totalCostSolarCredits': totalCostSolarCredits,
        'timestamp': timestamp.toIso8601String(),
      };

  factory EnergyTransaction.fromJson(Map<String, dynamic> json) {
    return EnergyTransaction(
      id: json['id'] as String,
      sellerId: json['sellerId'] as String,
      buyerId: json['buyerId'] as String,
      offerId: json['offerId'] as String,
      amountWh: (json['amountWh'] as num).toDouble(),
      pricePerWh: (json['pricePerWh'] as num).toDouble(),
      totalCostSolarCredits: (json['totalCostSolarCredits'] as num).toDouble(),
      timestamp: DateTime.parse(json['timestamp'] as String),
    );
  }
}


// --- Main Application ---
// ... (Your existing main and SolarMitraSimulationApp class remain mostly the same)
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(SolarMitraSimulationApp());
}

class SolarMitraSimulationApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'SolarMitra Simulator', // Updated title
      theme: ThemeData(
          primarySwatch: Colors.green,
          visualDensity: VisualDensity.adaptivePlatformDensity,
          useMaterial3: true,
          inputDecorationTheme: InputDecorationTheme(
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8.0),
            ),
            contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          ),
          elevatedButtonTheme: ElevatedButtonThemeData(
              style: ElevatedButton.styleFrom(
                  padding: EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8.0))))),
      home: RooftopManagementScreen(),
      debugShowCheckedModeBanner: false,
    );
  }
}


// --- Rooftop Management Screen (Modified) ---
class RooftopManagementScreen extends StatefulWidget {
  @override
  _RooftopManagementScreenState createState() =>
      _RooftopManagementScreenState();
}

class _RooftopManagementScreenState extends State<RooftopManagementScreen> {
  final DatabaseReference _dbRooftopRef = FirebaseDatabase.instance
      .ref("solar_system_sim/$currentUserId/rooftopSections"); // Path per user

  String? _selectedRooftopId;
  Map<String, RooftopSection> _rooftopSections = {};

  @override
  void initState() {
    super.initState();
    _listenToRooftopSections();
  }

  void _listenToRooftopSections() {
    _dbRooftopRef.onValue.listen((DatabaseEvent event) {
      final Map<String, RooftopSection> loadedSections = {};
      if (event.snapshot.exists && event.snapshot.value != null) {
        final data = event.snapshot.value as Map<dynamic, dynamic>;
        data.forEach((key, value) {
          if (key is String && value is Map) {
            loadedSections[key] =
                RooftopSection.fromJson(value.cast<String, dynamic>());
          }
        });
      }
      if (mounted) {
        setState(() {
          _rooftopSections = loadedSections;
          if (_selectedRooftopId != null &&
              !_rooftopSections.containsKey(_selectedRooftopId)) {
            _selectedRooftopId = null;
          }
          if (_selectedRooftopId == null && _rooftopSections.isNotEmpty) {
            _selectedRooftopId = _rooftopSections.keys.first;
          }
        });
      }
    }, onError: (error) {
      print("Firebase error (Rooftops): $error");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("Error loading rooftop data: $error"),
              backgroundColor: Colors.red),
        );
      }
    });
  }

  // ... (Your existing _addRooftopSectionDialog, _deleteRooftopSection, _buildRooftopInfoCard,
  //      _infoRow, _buildPanelList, _addPanelDialog, _removePanel, _togglePanelFaultyStatus methods
  //      remain the same. Ensure they use _dbRooftopRef)

  // --- Methods from your original code ---
  void _addRooftopSectionDialog() {
    final nameController = TextEditingController();
    final lengthController = TextEditingController();
    final widthController = TextEditingController();
    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text("Add Rooftop Section"),
        content: Form(
          key: formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                TextFormField(
                  controller: nameController,
                  decoration: InputDecoration(
                      labelText: "Section Name (e.g., Main Roof)"),
                  validator: (value) => (value == null || value.isEmpty)
                      ? "Name is required"
                      : null,
                ),
                SizedBox(height: 10),
                TextFormField(
                  controller: lengthController,
                  decoration:
                      InputDecoration(labelText: "Roof Length (meters)"),
                  keyboardType: TextInputType.numberWithOptions(decimal: true),
                  validator: (value) {
                    if (value == null || value.isEmpty)
                      return "Length is required";
                    final val = double.tryParse(value);
                    if (val == null || val <= 0)
                      return "Enter a valid positive length";
                    return null;
                  },
                ),
                SizedBox(height: 10),
                TextFormField(
                  controller: widthController,
                  decoration: InputDecoration(labelText: "Roof Width (meters)"),
                  keyboardType: TextInputType.numberWithOptions(decimal: true),
                  validator: (value) {
                    if (value == null || value.isEmpty)
                      return "Width is required";
                    final val = double.tryParse(value);
                    if (val == null || val <= 0)
                      return "Enter a valid positive width";
                    return null;
                  },
                ),
              ],
            ),
          ),
        ),
        actions: <Widget>[
          TextButton(
              onPressed: () => Navigator.of(dialogContext).pop(),
              child: Text("Cancel")),
          ElevatedButton(
            onPressed: () async {
              if (formKey.currentState!.validate()) {
                final newId = uuid.v4();
                final newSection = RooftopSection(
                  id: newId,
                  name: nameController.text.trim(),
                  roofLengthM: double.parse(lengthController.text),
                  roofWidthM: double.parse(widthController.text),
                );
                try {
                  await _dbRooftopRef.child(newId).set(newSection.toJson());
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("${newSection.name} added!"),
                      backgroundColor: Colors.green,
                    ));
                    Navigator.of(dialogContext).pop();
                    setState(() {
                      _selectedRooftopId = newId;
                    });
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("Failed to add section: $e"),
                      backgroundColor: Colors.red,
                    ));
                  }
                }
              }
            },
            child: Text("Add Section"),
          ),
        ],
      ),
    );
  }

  void _deleteRooftopSection(String rooftopId, String rooftopName) {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text("Confirm Delete"),
        content: Text(
            "Are you sure you want to delete '$rooftopName' and all its panels? This action cannot be undone."),
        actions: <Widget>[
          TextButton(
              onPressed: () => Navigator.of(dialogContext).pop(),
              child: Text("Cancel")),
          TextButton(
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            onPressed: () async {
              try {
                await _dbRooftopRef.child(rooftopId).remove();
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                    content: Text("Rooftop section '$rooftopName' deleted."),
                    backgroundColor: Colors.orange,
                  ));
                  Navigator.of(dialogContext).pop();
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                    content: Text("Failed to delete section: $e"),
                    backgroundColor: Colors.red,
                  ));
                }
              }
            },
            child: Text("Delete"),
          ),
        ],
      ),
    );
  }
    Widget _buildRooftopInfoCard(RooftopSection rooftop) {
    return Card(
      elevation: 2,
      margin: EdgeInsets.symmetric(vertical: 8),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                    child: Text(rooftop.name,
                        style: Theme.of(context).textTheme.headlineSmall,
                        overflow: TextOverflow.ellipsis)),
                IconButton(
                  icon: Icon(Icons.delete_sweep_outlined,
                      color: Colors.redAccent),
                  tooltip: "Delete '${rooftop.name}' Section",
                  onPressed: () =>
                      _deleteRooftopSection(rooftop.id, rooftop.name),
                )
              ],
            ),
            SizedBox(height: 12),
            _infoRow("Dimensions:",
                "${rooftop.roofLengthM.toStringAsFixed(1)}m x ${rooftop.roofWidthM.toStringAsFixed(1)}m"),
            _infoRow(
                "Total Area:", "${rooftop.totalAreaM2.toStringAsFixed(2)} m²"),
            _infoRow(
                "Area Used:", "${rooftop.usedAreaM2.toStringAsFixed(2)} m²",
                color: Colors.orange.shade700),
            _infoRow("Remaining Area:",
                "${rooftop.remainingAreaM2.toStringAsFixed(2)} m²",
                color: Colors.green.shade700, isBold: true),
            Divider(height: 20, thickness: 0.5),
            _infoRow("Total Wattage:", "${rooftop.totalWattageW} W"),
            _infoRow("Active Wattage:", "${rooftop.activeWattageW} W",
                color: Colors.blue.shade700, isBold: true),
          ],
        ),
      ),
    );
  }

  Widget _infoRow(String label, String value,
      {Color? color, bool isBold = false}) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 3.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: TextStyle(color: Colors.grey[700])),
          Text(
            value,
            style: TextStyle(
              fontWeight: isBold ? FontWeight.bold : FontWeight.normal,
              color: color ?? Theme.of(context).textTheme.bodyLarge?.color,
              fontSize: isBold ? 15 : 14,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPanelList(RooftopSection rooftop) {
    if (rooftop.panels.isEmpty) {
      return Padding(
        padding: const EdgeInsets.symmetric(vertical: 20.0),
        child: Center(
            child: Text("No panels added to this section yet.",
                style: TextStyle(color: Colors.grey[600]))),
      );
    }
    return ListView.builder(
      shrinkWrap: true,
      physics: NeverScrollableScrollPhysics(),
      itemCount: rooftop.panels.length,
      itemBuilder: (context, index) {
        final panelId = rooftop.panels.keys.elementAt(index);
        final panel = rooftop.panels[panelId]!;
        return Card(
          elevation: 1.5,
          margin: EdgeInsets.symmetric(vertical: 5),
          child: ListTile(
            leading: Icon(
                panel.isFaulty
                    ? Icons.warning_amber_rounded
                    : Icons.solar_power_rounded,
                color: panel.isFaulty
                    ? Colors.orangeAccent
                    : Colors.amber.shade700,
                size: 30),
            title: Text("${panel.modelName} (${panel.wattageW}W)",
                style: TextStyle(fontWeight: FontWeight.w500)),
            subtitle: Text(
                "Size: ${panel.lengthM}m x ${panel.widthM}m (${panel.areaM2.toStringAsFixed(2)} m²)\nStatus: ${panel.isFaulty ? 'FAULTY' : 'Operational'}"),
            isThreeLine: true,
            trailing: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  icon: Icon(
                      panel.isFaulty
                          ? Icons.unpublished_outlined
                          : Icons.error_outline_rounded,
                      color: panel.isFaulty ? Colors.green : Colors.orange),
                  tooltip:
                      panel.isFaulty ? "Mark as Operational" : "Mark as Faulty",
                  onPressed: () => _togglePanelFaultyStatus(rooftop.id, panel),
                ),
                IconButton(
                  icon: Icon(Icons.delete_outline_rounded,
                      color: Colors.redAccent),
                  tooltip: "Remove Panel",
                  onPressed: () =>
                      _removePanel(rooftop.id, panel.id, panel.modelName),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  void _addPanelDialog(RooftopSection rooftop) {
    final modelController = TextEditingController();
    final lengthController = TextEditingController();
    final widthController = TextEditingController();
    final wattageController = TextEditingController();
    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text("Add Panel to ${rooftop.name}"),
        content: Form(
          key: formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                TextFormField(
                  controller: modelController,
                  decoration: InputDecoration(labelText: "Panel Model"),
                  validator: (v) => (v == null || v.isEmpty)
                      ? "Model name is required"
                      : null,
                ),
                SizedBox(height: 10),
                TextFormField(
                  controller: lengthController,
                  decoration: InputDecoration(labelText: "Panel Length (m)"),
                  keyboardType: TextInputType.numberWithOptions(decimal: true),
                  validator: (v) {
                    if (v == null || v.isEmpty) return "Length is required";
                    final val = double.tryParse(v);
                    if (val == null || val <= 0)
                      return "Enter a valid positive length";
                    return null;
                  },
                ),
                SizedBox(height: 10),
                TextFormField(
                  controller: widthController,
                  decoration: InputDecoration(labelText: "Panel Width (m)"),
                  keyboardType: TextInputType.numberWithOptions(decimal: true),
                  validator: (v) {
                    if (v == null || v.isEmpty) return "Width is required";
                    final val = double.tryParse(v);
                    if (val == null || val <= 0)
                      return "Enter a valid positive width";
                    return null;
                  },
                ),
                SizedBox(height: 10),
                TextFormField(
                  controller: wattageController,
                  decoration: InputDecoration(labelText: "Panel Wattage (W)"),
                  keyboardType: TextInputType.number,
                  validator: (v) {
                    if (v == null || v.isEmpty) return "Wattage is required";
                    final val = int.tryParse(v);
                    if (val == null || val <= 0)
                      return "Enter a valid positive wattage";
                    return null;
                  },
                ),
              ],
            ),
          ),
        ),
        actions: <Widget>[
          TextButton(
              onPressed: () => Navigator.of(dialogContext).pop(),
              child: Text("Cancel")),
          ElevatedButton(
            onPressed: () async {
              if (formKey.currentState!.validate()) {
                final panelLength = double.parse(lengthController.text);
                final panelWidth = double.parse(widthController.text);
                final panelArea = panelLength * panelWidth;

                if (panelArea > rooftop.remainingAreaM2 + 0.001) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                          content: Text(
                              "Not enough space! Panel: ${panelArea.toStringAsFixed(2)}m², Available: ${rooftop.remainingAreaM2.toStringAsFixed(2)}m²"),
                          backgroundColor: Colors.red),
                    );
                  }
                  return;
                }

                final newPanelId = uuid.v4();
                final newPanel = SolarPanel(
                  id: newPanelId,
                  modelName: modelController.text.trim(),
                  lengthM: panelLength,
                  widthM: panelWidth,
                  wattageW: int.parse(wattageController.text),
                  addedTimestamp: DateTime.now(),
                );

                try {
                  await _dbRooftopRef // Use the correct ref
                      .child(rooftop.id)
                      .child('panels')
                      .child(newPanelId)
                      .set(newPanel.toJson());
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                        content: Text("${newPanel.modelName} added!"),
                        backgroundColor: Colors.green));
                    Navigator.of(dialogContext).pop();
                  }
                } catch (e) {
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                        content: Text("Failed to add panel: $e"),
                        backgroundColor: Colors.red));
                  }
                }
              }
            },
            child: Text("Add Panel"),
          ),
        ],
      ),
    );
  }

  void _removePanel(String rooftopId, String panelId, String panelName) {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text("Confirm Remove Panel"),
        content: Text("Are you sure you want to remove '$panelName'?"),
        actions: <Widget>[
          TextButton(
              onPressed: () => Navigator.of(dialogContext).pop(),
              child: Text("Cancel")),
          TextButton(
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            onPressed: () async {
              try {
                await _dbRooftopRef // Use the correct ref
                    .child(rooftopId)
                    .child('panels')
                    .child(panelId)
                    .remove();
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("Panel '$panelName' removed."),
                      backgroundColor: Colors.orange));
                  Navigator.of(dialogContext).pop();
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("Failed to remove panel: $e"),
                      backgroundColor: Colors.red));
                }
              }
            },
            child: Text("Remove"),
          ),
        ],
      ),
    );
  }

  void _togglePanelFaultyStatus(String rooftopId, SolarPanel panel) async {
    final newFaultyStatus = !panel.isFaulty;
    try {
      await _dbRooftopRef // Use the correct ref
          .child(rooftopId)
          .child('panels')
          .child(panel.id)
          .child('isFaulty')
          .set(newFaultyStatus);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text(
                  "${panel.modelName} marked as ${newFaultyStatus ? 'FAULTY' : 'Operational'}."),
              backgroundColor:
                  newFaultyStatus ? Colors.orangeAccent : Colors.lightGreen),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
            content: Text("Failed to update panel status: $e"),
            backgroundColor: Colors.red));
      }
    }
  }


  @override
  Widget build(BuildContext context) {
    RooftopSection? currentRooftop = (_selectedRooftopId != null &&
            _rooftopSections.containsKey(_selectedRooftopId))
        ? _rooftopSections[_selectedRooftopId!]
        : null;

    return Scaffold(
      appBar: AppBar(
        title: Text("Solar Panel Configuration"),
        actions: [
          IconButton( // NEW: Button to navigate to Energy Trading Dashboard
            icon: Icon(Icons.account_balance_wallet_outlined),
            tooltip: "Energy Trading & PoSW",
            onPressed: () {
              Navigator.of(context).push(MaterialPageRoute(
                builder: (context) => EnergyTradingDashboardScreen(
                  userId: currentUserId,
                  allRooftopSections: _rooftopSections, // Pass all sections
                ),
              ));
            },
          ),
          IconButton(
            icon: Icon(Icons.add_circle_outline),
            tooltip: "Add Rooftop Section",
            onPressed: _addRooftopSectionDialog,
          ),
        ],
      ),
      body: Column(
        children: [
          if (_rooftopSections.isNotEmpty)
            Padding(
              padding: const EdgeInsets.all(12.0),
              child: DropdownButtonFormField<String>(
                decoration: InputDecoration(
                  labelText: "Select Rooftop Section",
                ),
                value: _selectedRooftopId,
                items: _rooftopSections.entries.map((entry) {
                  return DropdownMenuItem<String>(
                    value: entry.key,
                    child:
                        Text(entry.value.name, overflow: TextOverflow.ellipsis),
                  );
                }).toList(),
                onChanged: (String? newValue) {
                  setState(() {
                    _selectedRooftopId = newValue;
                  });
                },
                isExpanded: true,
              ),
            ),
          if (_rooftopSections.isEmpty)
            Expanded(
              child: Center(
                  child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Text(
                    "No rooftop sections defined.\nClick '+' in the app bar to add one.",
                    textAlign: TextAlign.center,
                    style: TextStyle(fontSize: 16, color: Colors.grey[600])),
              )),
            ),
          if (currentRooftop != null)
            Expanded(
              child: SingleChildScrollView(
                padding: EdgeInsets.fromLTRB(16.0, 0, 16.0, 16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    _buildRooftopInfoCard(currentRooftop),
                    SizedBox(height: 16),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text("Solar Panels",
                            style: Theme.of(context).textTheme.titleLarge),
                        ElevatedButton.icon(
                          icon: Icon(Icons.solar_power_outlined),
                          label: Text("Add Panel"),
                          onPressed: () => _addPanelDialog(currentRooftop),
                        ),
                      ],
                    ),
                    SizedBox(height: 10),
                    _buildPanelList(currentRooftop),
                  ],
                ),
              ),
            )
          else if (_rooftopSections.isNotEmpty && _selectedRooftopId == null)
            Expanded(
              child: Center(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Text(
                      "Please select a rooftop section from the dropdown above.",
                      textAlign: TextAlign.center,
                      style: TextStyle(fontSize: 16, color: Colors.grey[700])),
                ),
              ),
            ),
        ],
      ),
    );
  }
}


// --- NEW: Energy Trading Dashboard Screen ---
class EnergyTradingDashboardScreen extends StatefulWidget {
  final String userId;
  final Map<String, RooftopSection> allRooftopSections; // To calculate total active wattage

  const EnergyTradingDashboardScreen({
    Key? key,
    required this.userId,
    required this.allRooftopSections,
  }) : super(key: key);

  @override
  _EnergyTradingDashboardScreenState createState() =>
      _EnergyTradingDashboardScreenState();
}

class _EnergyTradingDashboardScreenState extends State<EnergyTradingDashboardScreen> {
  final DatabaseReference _dbBaseRef = FirebaseDatabase.instance.ref("solar_system_sim"); // Base for user specific and market
  DatabaseReference get _walletRef => _dbBaseRef.child(widget.userId).child("wallet");
  DatabaseReference get _poswRecordsRef => _dbBaseRef.child(widget.userId).child("posw_records");
  DatabaseReference get _energyMarketOffersRef => _dbBaseRef.child("energy_market/sell_offers");
  DatabaseReference get _transactionsRef => _dbBaseRef.child("transactions");

  UserWallet? _userWallet;
  List<PoSWRecord> _poswHistory = [];
  List<EnergyOffer> _sellOffers = []; // All open offers in the market
  List<EnergyTransaction> _userTransactions = [];

  final double _poswCreditsPer100WPerHour = 1.0;
  final Duration _poswClaimCooldown = Duration(hours: 1); // Cooldown for PoSW claim

  @override
  void initState() {
    super.initState();
    _listenToWallet();
    _listenToPoSWHistory();
    _listenToEnergyMarket();
    _listenToUserTransactions();
  }

  void _listenToWallet() {
    _walletRef.onValue.listen((event) {
      if (mounted) {
        if (event.snapshot.exists && event.snapshot.value != null) {
          setState(() {
            _userWallet = UserWallet.fromJson(
                (event.snapshot.value as Map).cast<String, dynamic>());
          });
        } else {
          // Initialize wallet if it doesn't exist
          final newWallet = UserWallet(userId: widget.userId);
          _walletRef.set(newWallet.toJson()).then((_) {
             setState(() => _userWallet = newWallet);
          });
        }
      }
    }, onError: (e) => _showErrorSnackbar("Error loading wallet: $e"));
  }

  void _listenToPoSWHistory() {
    _poswRecordsRef.orderByChild('timestamp').limitToLast(20).onValue.listen((event) {
      if (mounted && event.snapshot.exists && event.snapshot.value != null) {
        final data = event.snapshot.value as Map<dynamic, dynamic>;
        final List<PoSWRecord> records = [];
        data.forEach((key, value) {
          records.add(PoSWRecord.fromJson((value as Map).cast<String, dynamic>()));
        });
        setState(() => _poswHistory = records.reversed.toList()); // Show newest first
      } else if (mounted) {
        setState(() => _poswHistory = []);
      }
    }, onError: (e) => _showErrorSnackbar("Error loading PoSW history: $e"));
  }

  void _listenToEnergyMarket() {
    _energyMarketOffersRef.orderByChild('timestamp').onValue.listen((event) {
       if (mounted && event.snapshot.exists && event.snapshot.value != null) {
        final data = event.snapshot.value as Map<dynamic, dynamic>;
        final List<EnergyOffer> offers = [];
        data.forEach((key, value) {
          final offer = EnergyOffer.fromJson((value as Map).cast<String, dynamic>());
          if (offer.status == EnergyOfferStatus.open) { // Only show open offers
             offers.add(offer);
          }
        });
        setState(() => _sellOffers = offers.reversed.toList()); // Newest first
      } else if (mounted) {
        setState(() => _sellOffers = []);
      }
    }, onError: (e) => _showErrorSnackbar("Error loading energy market: $e"));
  }

 void _listenToUserTransactions() {
    // This is a bit more complex as Firebase doesn't support OR queries easily.
    // We'll fetch all and filter client-side, or listen to two streams.
    // For simplicity, fetching all and filtering. For larger scale, consider duplicating refs or Cloud Functions.
    _transactionsRef.orderByChild('timestamp').limitToLast(50).onValue.listen((event) {
      if (mounted && event.snapshot.exists && event.snapshot.value != null) {
        final data = event.snapshot.value as Map<dynamic, dynamic>;
        final List<EnergyTransaction> allTransactions = [];
        data.forEach((key, value) {
          allTransactions.add(EnergyTransaction.fromJson((value as Map).cast<String, dynamic>()));
        });
        setState(() {
          _userTransactions = allTransactions
              .where((tx) => tx.buyerId == widget.userId || tx.sellerId == widget.userId)
              .toList().reversed.toList(); // Newest first
        });
      } else if (mounted) {
        setState(() => _userTransactions = []);
      }
    }, onError: (e) => _showErrorSnackbar("Error loading transaction history: $e"));
  }


  void _showErrorSnackbar(String message) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(message), backgroundColor: Colors.red));
    }
  }
  void _showSuccessSnackbar(String message) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(message), backgroundColor: Colors.green));
    }
  }

  int _getTotalActiveWattage() {
    return widget.allRooftopSections.values
        .fold(0, (sum, section) => sum + section.activeWattageW);
  }

  Future<void> _claimPoSW() async {
    if (_userWallet == null) {
      _showErrorSnackbar("Wallet not loaded yet.");
      return;
    }

    final now = DateTime.now();
    if (_userWallet!.lastPoSWClaimTimestamp != null &&
        now.difference(_userWallet!.lastPoSWClaimTimestamp!) < _poswClaimCooldown) {
      final remainingTime = _poswClaimCooldown - now.difference(_userWallet!.lastPoSWClaimTimestamp!);
      _showErrorSnackbar("Please wait ${remainingTime.inMinutes} more minutes to claim PoSW.");
      return;
    }

    final totalActiveWattage = _getTotalActiveWattage();
    if (totalActiveWattage <= 0) {
      _showErrorSnackbar("No active solar wattage to claim PoSW.");
      return;
    }

    // Simulate 1 hour of generation for simplicity
    final double creditsEarned = (totalActiveWattage / 100.0) * _poswCreditsPer100WPerHour;
    final newPoSWRecordId = uuid.v4();
    final poswRecord = PoSWRecord(
      id: newPoSWRecordId,
      userId: widget.userId,
      timestamp: now,
      wattageClaimedW: totalActiveWattage,
      creditsEarned: creditsEarned,
    );

    final newBalance = _userWallet!.balanceSolarCredits + creditsEarned;

    try {
      // Use a transaction to update wallet and add PoSW record atomically (simulated)
      // For true atomicity in Firebase for complex operations, Cloud Functions are better.
      // Here, we do sequential writes.
      await _poswRecordsRef.child(newPoSWRecordId).set(poswRecord.toJson());
      await _walletRef.update({
        'balanceSolarCredits': newBalance,
        'lastPoSWClaimTimestamp': now.toIso8601String(),
      });
      _showSuccessSnackbar("PoSW Claimed! +${creditsEarned.toStringAsFixed(2)} SolarCredits.");
    } catch (e) {
      _showErrorSnackbar("Failed to claim PoSW: $e");
    }
  }

  void _showCreateSellOfferDialog() {
    final amountController = TextEditingController();
    final priceController = TextEditingController();
    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text("Create Energy Sell Offer"),
        content: Form(
          key: formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextFormField(
                controller: amountController,
                decoration: InputDecoration(labelText: "Energy Amount (Wh)"),
                keyboardType: TextInputType.numberWithOptions(decimal: true),
                validator: (v) {
                  if (v == null || v.isEmpty) return "Amount is required";
                  final val = double.tryParse(v);
                  if (val == null || val <= 0) return "Enter a positive amount";
                  return null;
                },
              ),
              SizedBox(height: 10),
              TextFormField(
                controller: priceController,
                decoration: InputDecoration(labelText: "Price per Wh (SolarCredits)"),
                keyboardType: TextInputType.numberWithOptions(decimal: true),
                validator: (v) {
                  if (v == null || v.isEmpty) return "Price is required";
                  final val = double.tryParse(v);
                  if (val == null || val <= 0) return "Enter a positive price";
                  return null;
                },
              ),
            ],
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.of(context).pop(), child: Text("Cancel")),
          ElevatedButton(
            onPressed: () async {
              if (formKey.currentState!.validate()) {
                final newOfferId = uuid.v4();
                final offer = EnergyOffer(
                  id: newOfferId,
                  sellerId: widget.userId,
                  amountWh: double.parse(amountController.text),
                  pricePerWh: double.parse(priceController.text),
                  timestamp: DateTime.now(),
                );
                try {
                  await _energyMarketOffersRef.child(newOfferId).set(offer.toJson());
                  _showSuccessSnackbar("Sell offer created successfully!");
                  Navigator.of(context).pop();
                } catch (e) {
                  _showErrorSnackbar("Failed to create offer: $e");
                }
              }
            },
            child: Text("Create Offer"),
          )
        ],
      ),
    );
  }

  Future<void> _buyEnergyOffer(EnergyOffer offer) async {
     if (_userWallet == null) {
      _showErrorSnackbar("Wallet not loaded.");
      return;
    }
    if (offer.sellerId == widget.userId) {
      _showErrorSnackbar("You cannot buy your own offer.");
      return;
    }

    final totalCost = offer.totalPrice;
    if (_userWallet!.balanceSolarCredits < totalCost) {
      _showErrorSnackbar("Not enough SolarCredits. Required: ${totalCost.toStringAsFixed(2)}, Available: ${_userWallet!.balanceSolarCredits.toStringAsFixed(2)}");
      return;
    }

    // Confirmation dialog
    bool? confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text("Confirm Purchase"),
        content: Text(
            "Buy ${offer.amountWh.toStringAsFixed(0)}Wh for ${totalCost.toStringAsFixed(2)} SolarCredits?"),
        actions: [
          TextButton(onPressed: () => Navigator.of(context).pop(false), child: Text("Cancel")),
          ElevatedButton(onPressed: () => Navigator.of(context).pop(true), child: Text("Buy")),
        ],
      ),
    );

    if (confirmed != true) return;


    final transactionId = uuid.v4();
    final transaction = EnergyTransaction(
      id: transactionId,
      sellerId: offer.sellerId,
      buyerId: widget.userId,
      offerId: offer.id,
      amountWh: offer.amountWh,
      pricePerWh: offer.pricePerWh,
      totalCostSolarCredits: totalCost,
      timestamp: DateTime.now(),
    );

    // This should ideally be an atomic transaction using Firebase Cloud Functions for reliability
    // For client-side simulation:
    try {
      // 1. Update seller's wallet (get current, add, set)
      final sellerWalletSnapshot = await _dbBaseRef.child(offer.sellerId).child("wallet").get();
      UserWallet sellerWallet;
      if (sellerWalletSnapshot.exists && sellerWalletSnapshot.value != null) {
        sellerWallet = UserWallet.fromJson((sellerWalletSnapshot.value as Map).cast<String,dynamic>());
      } else {
        // This case should ideally not happen if sellers must have wallets
        sellerWallet = UserWallet(userId: offer.sellerId, balanceSolarCredits: 0);
      }
      await _dbBaseRef.child(offer.sellerId).child("wallet/balanceSolarCredits").set(sellerWallet.balanceSolarCredits + totalCost);

      // 2. Update buyer's wallet
      await _walletRef.child("balanceSolarCredits").set(_userWallet!.balanceSolarCredits - totalCost);
      
      // 3. Record the transaction
      await _transactionsRef.child(transactionId).set(transaction.toJson());
      
      // 4. Mark the offer as filled
      await _energyMarketOffersRef.child(offer.id).child("status").set(EnergyOfferStatus.filled.toString().split('.').last);

      _showSuccessSnackbar("Energy purchased successfully!");

    } catch (e) {
      _showErrorSnackbar("Transaction failed: $e. Wallets might be inconsistent. Please check.");
      // In a real app, you'd need rollback logic or server-side atomicity.
    }
  }


  @override
  Widget build(BuildContext context) {
    final totalActiveWattage = _getTotalActiveWattage();
    final currencyFormat = NumberFormat.currency(symbol: "SC ", decimalDigits: 2); // SC for SolarCredits

    return Scaffold(
      appBar: AppBar(title: Text("Energy Trading & PoSW")),
      body: RefreshIndicator(
        onRefresh: () async {
            // Manually trigger listeners or re-fetch data if needed
            // For simplicity, listeners should auto-update. This is mostly for UI refresh feel.
            setState(() {});
        },
        child: SingleChildScrollView(
          padding: EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // --- Wallet Info & PoSW ---
              Card(
                elevation: 2,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    children: [
                      Text("My Wallet", style: Theme.of(context).textTheme.headlineSmall),
                      SizedBox(height: 10),
                      if (_userWallet != null)
                        Text(currencyFormat.format(_userWallet!.balanceSolarCredits),
                            style: Theme.of(context).textTheme.headlineMedium?.copyWith(color: Colors.green.shade700))
                      else
                        CircularProgressIndicator(),
                      SizedBox(height: 10),
                       Text("Total Active Capacity: ${totalActiveWattage}W", style: TextStyle(fontSize: 16)),
                      SizedBox(height: 15),
                      ElevatedButton.icon(
                        icon: Icon(Icons.bolt),
                        label: Text("Claim Proof of Solar Work"),
                        onPressed: _claimPoSW,
                      ),
                       if (_userWallet?.lastPoSWClaimTimestamp != null)
                        Padding(
                          padding: const EdgeInsets.only(top: 8.0),
                          child: Text("Last claim: ${DateFormat.yMd().add_jm().format(_userWallet!.lastPoSWClaimTimestamp!)}", style: TextStyle(fontSize: 12, color: Colors.grey)),
                        ),
                    ],
                  ),
                ),
              ),
              SizedBox(height: 20),

              // --- Energy Market (Sell Offers) ---
              Text("Energy Market - Sell Offers", style: Theme.of(context).textTheme.titleLarge),
              SizedBox(height: 10),
              ElevatedButton.icon(
                icon: Icon(Icons.add_shopping_cart),
                label: Text("Create Sell Offer"),
                onPressed: _showCreateSellOfferDialog,
                style: ElevatedButton.styleFrom(backgroundColor: Colors.blueAccent),
              ),
              SizedBox(height: 10),
              _sellOffers.isEmpty
                  ? Center(child: Padding(padding: const EdgeInsets.all(16.0), child: Text("No open energy offers available.")))
                  : ListView.builder(
                      shrinkWrap: true,
                      physics: NeverScrollableScrollPhysics(),
                      itemCount: _sellOffers.length,
                      itemBuilder: (context, index) {
                        final offer = _sellOffers[index];
                        return Card(
                          margin: EdgeInsets.symmetric(vertical: 6),
                          child: ListTile(
                            leading: Icon(Icons.offline_bolt, color: Colors.amber.shade800),
                            title: Text("${offer.amountWh.toStringAsFixed(0)} Wh for ${currencyFormat.format(offer.totalPrice)}"),
                            subtitle: Text(
                                "Price: ${offer.pricePerWh.toStringAsFixed(3)} SC/Wh\nSeller: ${offer.sellerId == widget.userId ? 'You' : offer.sellerId.substring(0, min(8,offer.sellerId.length))+'...'}\nPosted: ${DateFormat.yMd().add_jm().format(offer.timestamp)}"),
                            trailing: offer.sellerId != widget.userId ? ElevatedButton(
                              child: Text("Buy"),
                              onPressed: () => _buyEnergyOffer(offer),
                              style: ElevatedButton.styleFrom(backgroundColor: Colors.teal, foregroundColor: Colors.white),
                            ) : Chip(label: Text("Your Offer"), backgroundColor: Colors.grey.shade300,),
                            isThreeLine: true,
                          ),
                        );
                      },
                    ),
              SizedBox(height: 20),

              // --- PoSW Claim History ---
              Text("My PoSW Claim History (Last 20)", style: Theme.of(context).textTheme.titleLarge),
              SizedBox(height: 10),
              _poswHistory.isEmpty
                  ? Center(child: Padding(padding: const EdgeInsets.all(16.0), child: Text("No PoSW claims yet.")))
                  : ListView.builder(
                      shrinkWrap: true,
                      physics: NeverScrollableScrollPhysics(),
                      itemCount: _poswHistory.length,
                      itemBuilder: (context, index) {
                        final record = _poswHistory[index];
                        return Card(
                           margin: EdgeInsets.symmetric(vertical: 4),
                          child: ListTile(
                             leading: Icon(Icons.offline_bolt_outlined, color: Colors.green),
                            title: Text("+${record.creditsEarned.toStringAsFixed(2)} SC for ${record.wattageClaimedW}W"),
                            subtitle: Text(DateFormat.yMd().add_jm().format(record.timestamp)),
                          ),
                        );
                      },
                    ),
              SizedBox(height: 20),
              
              // --- Transaction History ---
              Text("My Transaction History (Last 50)", style: Theme.of(context).textTheme.titleLarge),
              SizedBox(height: 10),
              _userTransactions.isEmpty
                  ? Center(child: Padding(padding: const EdgeInsets.all(16.0), child: Text("No transactions yet.")))
                  : ListView.builder(
                      shrinkWrap: true,
                      physics: NeverScrollableScrollPhysics(),
                      itemCount: _userTransactions.length,
                      itemBuilder: (context, index) {
                        final tx = _userTransactions[index];
                        bool isBuyer = tx.buyerId == widget.userId;
                        return Card(
                          margin: EdgeInsets.symmetric(vertical: 4),
                          child: ListTile(
                            leading: Icon(
                              isBuyer ? Icons.shopping_cart_checkout : Icons.sell_outlined,
                              color: isBuyer ? Colors.redAccent : Colors.blueAccent,
                            ),
                            title: Text("${isBuyer ? 'Bought' : 'Sold'} ${tx.amountWh.toStringAsFixed(0)} Wh"),
                            subtitle: Text(
                                "${isBuyer ? 'From' : 'To'}: ${ (isBuyer ? tx.sellerId : tx.buyerId).substring(0,min(8,(isBuyer ? tx.sellerId : tx.buyerId).length)) }...\nCost: ${currencyFormat.format(tx.totalCostSolarCredits)}\n${DateFormat.yMd().add_jm().format(tx.timestamp)}"),
                            isThreeLine: true,
                          ),
                        );
                      },
                    ),
            ],
          ),
        ),
      ),
    );
  }
}